== key words==
* auto
* decltype
      int i;
      double t;
      struct A { double x; };
      const A* a = new A();
      decltype(a) x1; // x1 is A *
      decltype(i) x2; // x2 is int
      decltype(a->x) x3; // x3 is double
      decltype((a->x)) x4 = t; // x4 is double&

* nullptr
* shared_ptr
shared_ptr<T> ptr(new T); // T 可以是 int ,char, 类名等各种类型
多个shared_ptr对象可以同时托管一个指针，系统会维护一个托管计数。当无shared_ptr托管该指针时， delete该指针。
shared_ptr对象不能托管指向动态分配的数组的指针，否则程序运行会出错
    shared_ptr<A> sp1(new A(2)); //sp1托管A(2)
    shared_ptr<A> sp2(sp1); //sp2也托管 A(2)
    shared_ptr<A> sp3 = sp1;
    cout << (*sp3).n << endl;
    A * p = sp1.get(); //p 指向 A(2)
    sp1.reset();
    shared_ptr<A> sp5;
    sp5.reset();// 会崩溃，因为没有托管任何指针


== C++ 11 Lambda表达式 ==
https://www.cnblogs.com/DswCnblog/p/5629165.html

[capture list] (params list) mutable exception-> return type { function body }
[] 值传递(空,=,指定值)，引用传递&，隐式传递(=)

参数在函数末端指定
auto x = [](int a){cout << a << endl;}(123); 

函数返回值可以根据return 自动推断

#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
int main()
{
    vector<int> a { 1,2,3,4};
    int total = 0;
    for_each(a.begin(),a.end(),[&](int & x) {total += x; x*=2;});
    cout << total << endl; //输出 10
    for_each(a.begin(),a.end(),[ ](int x) { cout << x << " ";});
    return 0;
}
//程序输出结果：
//10
//2 4 6 8

== loop ==
map<string, int> m{{"a", 1}, {"b", 2}, {"c", 3}};
for (auto &p : m){
    cout<<p.first<<" : "<<p.second<<endl;
}

== 变长參数的模板 tuple ==
以前只有pair
auto p = make_pair(1, "C++ 11");

tuple构造变长结构
auto t1 = make_tuple(1, 2.0, "C++ 11");
auto t2 = make_tuple(1, 2.0, "C++ 11", {1, 0, 2});

变长参数
template<typename head, typename... tail>
void Print(Head head, typename... tail) {
    cout<< head <<endl;
    Print(tail...);
}

Print(1, 1.0, "C++11");

== 参数初始化 大括号 ==
int arr[3]{1, 2, 3};
vector<int> iv{1, 2, 3};
map<int, string>{{1, "a"}, {2, "b"}};
string str{"Hello World"};

成员默认初始化
class B
{
public:
    int m = 1234;
    int n;
};

== 右值引用和move语义 ==
* 右值：一般来说，不能取地址的表达式，就是右值，能取地址的，就是左值; 左值可以赋值，右值不可以赋值
class A { };
A & r = A(); // error , A()是无名变量，是右值
A && r = A(); //ok, r 是右值引用

主要目的是提高程序运行的效率，减少需要进行深拷贝的对象进行深拷贝的次数


* move
std::move语句可以将左值变为右值而避免拷贝构造
总之尽量给类添加移动构造和移动赋值函数，而减少拷贝构造和拷贝赋值的消耗。 移动构造，移动赋值要加上noexcept，用于通知标准库不抛出异常。
class A
{
public:
    A() { std::cout << "Constructor" << std::endl; }
    A(const A&) { std::cout << "Copy Constructor" << std::endl; }
    A(const A&&) { std::cout << "Move Constructor" << std::endl; }
    ~A() {}
};

static A getA()
{
    A a;
    return a;
}

int main()
{
    A a = getA();
    
    return 0;
}

== 无序容器 ==
#include <iostream>
#include <string>
#include <unordered_map>
using namespace std;
int main()
{
    unordered_map<string,int> turingWinner; //图灵奖获奖名单
    turingWinner.insert(make_pair("Dijkstra",1972));
    turingWinner.insert(make_pair("Scott",1976));
    turingWinner.insert(make_pair("Wilkes",1967));
    turingWinner.insert(make_pair("Hamming",1968));
    turingWinner["Ritchie"] = 1983;
    string name;
    cin >> name; //输入姓名
    4
        unordered_map<string,int>::iterator p = turingWinner.find(name);
    //据姓名查获奖时间
    if( p != turingWinner.end())
        cout << p->second;
    else
        cout << "Not Found" << endl;
    return 0;
}
//哈希表插入和查询的时间复杂度几乎是常数

== 正则表达式 ==
#include <iostream>
#include <regex> //使用正则表达式须包含此文件
using namespace std;
int main()
{
    regex reg("b.?p.*k");
    cout << regex_match("bopggk",reg) <<endl; //输出 1, 表示匹配成功
    cout << regex_match("boopgggk",reg) <<endl; //输出 0, 表示匹配失败
    cout << regex_match("b pk",reg) <<endl; //输出 1, 表示匹配成功
    regex reg2("\\d{3}([a-zA-Z]+).(\\d{2}|N/A)\\s\\1");
    string correct="123Hello N/A Hello";
    string incorrect="123Hello 12 hello";
    cout << regex_match(correct,reg2) <<endl; //输出 1, 表示匹配成功
    cout << regex_match(incorrect,reg2) << endl; //输出 0, 表示匹配失败
}

== mem_fun 和 mem_fun_ref ==
https://blog.csdn.net/coolwriter/article/details/81533226



